# [Explainable AI for Embedded Systems Design: A Case Study of Static   Redundant NVM Memory Write Prediction](https://arxiv.org/abs/2403.04337)

## Write a very high-quality and detailed summary of the paper that describes the paper in a way that a human can fully understand. The summary should cover the problem, the proposed solution and highlight the main contributions of the paper.

 Here is a detailed summary of the key points from the paper:

Problem:
- Applying machine learning for embedded system design raises transparency concerns due to "black box" nature of complex models. Explainable AI (XAI) methods can address this by analyzing models to provide insights into their reasoning and decision making process.   

- This is explored through static silent store prediction for non-volatile memories, which eliminates redundant writes to improve efficiency. The challenge is training ML models to accurately predict silent stores based solely on static program features.

Proposed Solution:
- Develop a methodology with two main steps: (1) Train suitable ML models for predicting and explaining silent stores; (2) Apply two state-of-the-art XAI techniques - SHAP and Anchors -  to analyze the models trained in step 1.

- The goal is to identify static program features influencing silent store predictions and evaluate effectiveness of XAI methods. Precision and recall metrics guide selection of ML models catered for explainability.

Main Contributions:
- Provides first study demonstrating application of XAI to uncover causes of silent stores based on predictions of ML models trained only on static features.  

- XAI methods yield promising explanations consistent with known root causes from literature, e.g. writing zero constants to memory frequently leads to silent stores.

- Analysis uncovers insights and potential pitfalls regarding combining ML and XAI for embedded system design. 

- Establishes basis and direction for future research at intersection of XAI and embedded systems to promote transparency. Potential for optimizing compilers and architectures.
